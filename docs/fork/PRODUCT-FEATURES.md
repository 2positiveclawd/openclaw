# OpenClawd Product Features & Technical Reference

> **Purpose:** This document provides comprehensive product documentation for the OpenClawd AI agent system. It is designed to be the single source of truth from which a landing page, sales copy, quick start guides, and how-to docs can be generated by another agent or human. Every section below contains enough technical detail, CLI examples, and configuration snippets to produce accurate marketing and documentation materials without further source-code exploration.

---

## Table of Contents

1. [Product Overview](#1-product-overview)
2. [Core Architecture](#2-core-architecture)
3. [Extensions (Deep Dive)](#3-extensions-deep-dive)
   - [Goal Loop](#31-goal-loop)
   - [Planner](#32-planner)
   - [Researcher](#33-researcher)
   - [Trend Scout](#34-trend-scout)
   - [Agent Packs](#35-agent-packs)
   - [Automation](#36-automation)
4. [Mission Control Dashboard](#4-mission-control-dashboard)
5. [Agent System Details](#5-agent-system-details)
6. [Security Model](#6-security-model)
7. [Quick Start Guide](#7-quick-start-guide)
8. [Feature Comparison Table](#8-feature-comparison-table)
9. [Pricing and Licensing Considerations](#9-pricing-and-licensing-considerations)

---

## 1. Product Overview

### Elevator Pitch

OpenClawd is a self-hosted AI agent orchestration system that turns a single gateway process into a fleet of 24+ specialized AI agents, each with persistent memory, isolated workspaces, and the ability to autonomously pursue complex goals. Built as a fork of the open-source OpenClaw gateway, OpenClawd adds six custom extensions -- Goal Loop, Planner, Researcher, Trend Scout, Agent Packs, and Automation -- that enable autonomous goal execution, DAG-based task planning, interview-driven product requirement generation, real-time trend monitoring, pre-built personality agent teams, and event-driven workflow automation. All of this is accessible through a Discord bot interface and monitored via a local-first Mission Control Dashboard.

### Who Is It For?

| Audience                                             | Why OpenClawd                                                                                                                         |
| ---------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| **Solo founders / solopreneurs**                     | Replace entire support teams with specialized AI agents for content, outreach, finance, and more                                      |
| **Developer teams**                                  | Get autonomous code review, documentation, and tech-lead agents alongside a planner that decomposes goals into parallelized task DAGs |
| **AI enthusiasts / builders**                        | Self-hosted, fully customizable agent infrastructure with no vendor lock-in                                                           |
| **Automation engineers**                             | Event-driven chains, webhooks, and templates that connect agent outputs to downstream systems                                         |
| **Product managers**                                 | Interview-driven PRD generation (Researcher) and autonomous goal tracking (Goal Loop) with budget governance                          |
| **Health, fitness, and personal productivity users** | Pre-built agent packs for coaching, wellness, habit tracking, and tax/finance management                                              |

### Key Differentiators vs Other AI Agent Systems

| Differentiator                       | Detail                                                                                                                                                                                    |
| ------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **True multi-agent isolation**       | Each of the 24 agents has its own workspace, session history, SOUL personality file, and memory index. Agents cannot see each other's memories unless explicitly configured.              |
| **Budget governance built in**       | Every autonomous operation (goal, plan, research) enforces iteration, token, time, and provider-usage budgets with 80% warnings, circuit breakers, and stall detection. No runaway spend. |
| **Self-hosted, local-first**         | Gateway binds to loopback only. Dashboard runs on localhost. No data leaves your machine unless you configure external providers.                                                         |
| **DAG-based task planning**          | The Planner decomposes goals into a directed acyclic graph of tasks with dependency tracking, parallel worker dispatch, and automatic replanning on failure.                              |
| **Interview-driven requirements**    | The Researcher conducts multi-round interviews (via Discord buttons or CLI), then generates a complete PRD and optionally launches the Planner to build it -- all in one flow.            |
| **Pluggable extension architecture** | Extensions are self-contained workspace packages loaded at runtime via jiti. No need to fork core code -- register plugins and they appear as CLI commands and gateway features.          |
| **Pre-built agent teams**            | Six thematic Agent Packs (18 agents) provide ready-to-use teams for content creation, development, solopreneurship, fitness, health, and finance.                                         |
| **Persistent semantic memory**       | Each agent's workspace files and past conversations are indexed with vector embeddings (SQLite + OpenAI embeddings). Agents recall past context automatically.                            |
| **Automation event system**          | Webhooks, chains, and templates let you wire agent outputs to external systems or trigger follow-up agent workflows based on events like `goal.completed` or `plan.failed`.               |

---

## 2. Core Architecture

### 2.1 Gateway Runtime

The OpenClawd gateway is a long-running Node.js process that serves as the runtime for all agent operations.

**Key Characteristics:**

- **Runtime:** Node.js 22+ (TypeScript, ESM)
- **Process management:** systemd user service (`openclaw-gateway.service`)
- **Port:** 18789 (loopback-bound by default)
- **Configuration:** `~/.openclaw/openclaw.json` (single JSON5 file)
- **Secrets:** `~/.openclaw/.secrets.env` (chmod 600, loaded at startup)

**Architecture Diagram:**

```
                    Discord Bot
                        |
                   (Carbon SDK)
                        |
           +------------+-------------+
           |     OpenClaw Gateway      |
           |      (port 18789)         |
           +--+-----+-----+-----+----+
              |     |     |     |    |
         +----+  +--+-+  +-+-+  +-+-+  +--+--+
         |Goal|  |Plan|  |Res|  |Trd|  |Auto |
         |Loop|  |ner |  |rch|  |Sct|  |mtn  |
         +----+  +----+  +---+  +---+  +-----+
              |     |      |      |       |
         +----+-----+------+------+-------+
         |        Agent Packs (18)         |
         |   Content | Dev | Solo | ...    |
         +---------------------------------+
                        |
              +---------+---------+
              | Per-Agent Storage  |
              | - Sessions (JSONL) |
              | - Workspace (files)|
              | - Memory (SQLite)  |
              | - SOUL.md          |
              +--------------------+
```

**Starting the Gateway:**

```bash
# Via systemd (production)
systemctl --user start openclaw-gateway

# Via CLI (development)
pnpm openclaw gateway run --bind loopback --port 18789

# Check status
systemctl --user status openclaw-gateway

# View logs
journalctl --user -u openclaw-gateway -f
```

**Configuration Example (minimal):**

```json5
{
  // Provider configuration (e.g., Azure OpenAI)
  models: {
    providers: {
      azure: {
        baseUrl: "https://your-deployment.openai.azure.com/openai",
        apiKey: "your-api-key",
        models: [{ id: "gpt-5-mini", alias: "default" }],
      },
    },
  },

  // Gateway settings
  gateway: {
    mode: "local",
    port: 18789,
    bind: "loopback",
    auth: {
      token: "your-gateway-token",
    },
  },

  // Plugins
  "goal-loop": { enabled: true },
  planner: { enabled: true },
  researcher: { enabled: true },
  "trend-scout": { enabled: true },
  "agent-packs": { enabled: true },
  automation: { enabled: true },

  // Agents (see Section 5)
  agents: {
    list: [
      // ... agent definitions ...
    ],
  },

  // Channel bindings
  bindings: [
    // ... binding definitions ...
  ],
}
```

### 2.2 Multi-Agent System

OpenClawd ships with 24 agents organized into two tiers:

**System Agents (6):**

| Agent ID     | Role                            | Used By                       |
| ------------ | ------------------------------- | ----------------------------- |
| `main`       | Default Discord bot agent       | Gateway default handler       |
| `travel`     | Travel planning and booking     | Standalone                    |
| `researcher` | Web research and analysis       | Researcher extension          |
| `planner`    | Task decomposition and planning | Planner extension             |
| `executor`   | Task execution worker           | Planner extension (workers)   |
| `qa`         | Quality evaluation and scoring  | Planner extension (evaluator) |

**Agent Packs (18 agents in 6 packs):**

| Pack              | Agents (3 each)                                   | Domain                                  |
| ----------------- | ------------------------------------------------- | --------------------------------------- |
| Content Creator   | mia-strategist, blake-scriptwriter, jordan-social | Content strategy, scripts, social media |
| Dev Team          | marcus-techlead, elena-reviewer, sam-docs         | Code review, docs, tech leadership      |
| Solopreneur       | claire-assistant, leo-researcher, harper-outreach | EA, research, outreach                  |
| Fitness Training  | noah-coach, nina-nutrition, ethan-accountability  | Workouts, nutrition, accountability     |
| Health & Wellness | olivia-wellness, mason-sleep, priya-habits        | Wellness, sleep, habits                 |
| Finance & Taxes   | sophia-invoices, liam-expenses, nora-tax          | Invoicing, expenses, tax prep           |

Each agent has:

1. **Identity** -- Name, emoji, description (in `openclaw.json`)
2. **SOUL (personality file)** -- Markdown file defining personality, responsibilities, tools, and communication style (in workspace)
3. **Workspace** -- Isolated directory for file I/O (`~/.openclaw/workspace-{agent-id}/`)
4. **Sessions** -- Conversation history and tool call logs (`~/.openclaw/agents/{agent-id}/sessions/*.jsonl`)
5. **Memory index** -- Vector embeddings of SOUL.md + past sessions (SQLite)

### 2.3 Plugin System

OpenClawd uses a jiti-based plugin architecture where extensions are loaded as workspace packages at runtime.

**How Extensions Work:**

1. Extensions live in `extensions/{name}/` as npm workspace packages
2. Each extension has a `openclaw.plugin.json` manifest that declares metadata, config schema, and CLI commands
3. At gateway startup, jiti (a runtime TypeScript transpiler) loads extension entry points
4. Extensions register CLI commands, event handlers, Discord button specs, and HTTP routes through the plugin SDK

**Extension Structure Pattern:**

```
extensions/{name}/
  package.json            # name, version, deps
  openclaw.plugin.json    # Plugin manifest
  index.ts                # Entry point (register function)
  tsconfig.json           # TypeScript config
  src/
    core-bridge.ts        # Imports from openclaw/plugin-sdk
    cli.ts                # CLI subcommand registration
    *-service.ts          # Core business logic
    types.ts              # Type definitions
```

**Dependency Pattern:**

- `devDependencies`: `"openclaw": "workspace:*"` (build-time resolution)
- `peerDependencies`: `"openclaw": "*"` (runtime resolution via jiti alias)
- NO `dependencies` on openclaw (prevents npm install breakage)

**The jiti/dist instanceof Pattern:**

A critical architectural pattern in OpenClawd addresses the fact that extensions loaded via jiti resolve `@buape/carbon` from `node_modules/`, while the gateway's built `dist/` code bundles its own copy. Since these are different class objects, `instanceof` checks fail across the boundary.

The solution is the **spec-based registry pattern**:

1. Extensions register plain spec objects (not class instances) during plugin load
2. The gateway provider creates real class instances from specs using the bundled classes
3. Carbon's `ComponentHandler` sees proper `instanceof` matches

**Key file:** `src/discord/monitor/component-registry.ts`

```typescript
// Extension registers a plain spec:
registerDiscordButton({
  customId: "mybutton",
  label: "Click Me",
  style: ButtonStyle.Primary,
  run: async (interaction) => {
    // handler logic
  },
});

// Provider drains specs and creates real Button instances:
const buttons = drainDiscordButtonSpecs();
// buttons are proper Button subclass instances with instanceof === true
```

### 2.4 Discord Integration

OpenClawd connects to Discord through the Carbon SDK (`@buape/carbon`), providing:

- **Message handling:** Incoming messages are routed to agents based on channel bindings
- **Ack reactions:** Each agent reacts with their emoji before processing (visual feedback)
- **Button interactions:** Extensions register interactive buttons (Approve/Reject/Info) for rich Discord UX
- **Embed messages:** Researcher interview questions, trend scout proposals, and notifications use Discord embeds
- **Multi-channel:** Each agent pack creates a Discord category with dedicated channels per agent

**Discord Channel Architecture:**

```
Server
  + Content Creator (category)
    - #mia-strategist
    - #blake-scriptwriter
    - #jordan-social
  + Dev Team (category)
    - #marcus-techlead
    - #elena-reviewer
    - #sam-docs
  + ... (4 more pack categories)
  + System Channels
    - #main (default agent)
    - #trend-scout (daily digests)
    - #notifications (goal/plan alerts)
```

**Routing Flow:**

```
Discord message arrives
  -> Gateway checks bindings[]
  -> Find binding where match.peer.id == channel ID
  -> Route to bound agentId
  -> Agent processes with isolated session + workspace
  -> Response sent back to channel
```

**Bot Permissions Required:**

- Send Messages
- Read Message History
- Add Reactions
- Use Application Commands
- Send Messages in Threads
- Use External Emojis

---

## 3. Extensions (Deep Dive)

### 3.1 Goal Loop

**What It Does:**

The Goal Loop extension implements autonomous goal-directed agent execution with iterative progress, LLM-based evaluation, stall detection, and comprehensive budget governance. It is the simplest and most focused orchestration tool -- best for single-purpose goals that benefit from an iterate-and-evaluate cycle.

**How It Works:**

```
                              +-----------+
                              |   START   |
                              +-----+-----+
                                    |
                              +-----v-----+
                         +--->|  ITERATE   |<---+
                         |    | (agent turn)|    |
                         |    +-----+------+    |
                         |          |           |
                         |    +-----v------+    |
                         |    | GOVERNANCE |    |
                         |    | CHECKS     |    |
                         |    +-----+------+    |
                         |          |           |
                         |    Pass? |  Fail?    |
                         |    |     +---------->+ STOP
                         |    |                 | (budget_exceeded)
                         |    +-----v------+    |
                         |    | EVALUATE?  |    |
                         |    | every N    |    |
                         |    +-----+------+    |
                         |          |           |
                         |    Yes   |  No       |
                         |    |     +-----+     |
                         |    |           |     |
                         |    +-----v------+    |
                         |    | EVALUATOR  |    |
                         |    | (LLM call) |    |
                         |    +-----+------+    |
                         |          |           |
                         |   Score  |  Stall?   |
                         |   < 95   |  ------->-+ STOP
                         |    |     |           | (stalled)
                         |    |   Score >= 95   |
                         |    |     |           |
                         |    |  +--v------+    |
                         +----+  |COMPLETED|    |
                              |  +---------+    |
                              +                 +
```

**State Machine:**

```
pending -> running -> evaluating -> running (loop)
                                 -> completed (score >= 95)
                                 -> budget_exceeded
                                 -> stopped (manual)
                                 -> failed (error)
         -> paused (quality gate) -> running (approved)
                                  -> stopped (rejected)
```

**Governance Checks (run before every iteration):**

| Check                | Description                                | Action on Fail              |
| -------------------- | ------------------------------------------ | --------------------------- |
| **Iteration Budget** | `usage.iterations >= budget.maxIterations` | Stop with `budget_exceeded` |
| **Token Budget**     | `usage.totalTokens >= budget.maxTokens`    | Stop with `budget_exceeded` |
| **Time Budget**      | `elapsed >= budget.maxTimeMs`              | Stop with `budget_exceeded` |
| **Provider Usage**   | API usage % exceeds threshold              | Stop with `budget_exceeded` |
| **Circuit Breaker**  | N consecutive errors (default: 3)          | Stop with `failed`          |
| **Stall Detection**  | Last N evaluations show < 5 point progress | Stop with `stalled`         |

All checks emit **80% warnings** when approaching limits, notified via configured channels.

**Evaluator:**

The evaluator is a separate LLM call (isolated session) that scores progress 0-100 against acceptance criteria. It runs every N iterations (configurable via `evalEvery`, default: 3).

Evaluator output schema:

```json
{
  "progressScore": 85,
  "assessment": "Core functionality complete, missing edge case handling",
  "criteriaStatus": [
    { "criterion": "User can sign up", "met": true, "notes": "Registration flow working" },
    { "criterion": "Email verification", "met": false, "notes": "Not yet implemented" }
  ],
  "shouldContinue": true,
  "suggestedNextAction": "Implement email verification flow"
}
```

**Quality Gates:**

Quality gates pause execution at specific iteration counts for human approval. When a gate triggers:

1. Goal status changes to `paused`
2. Notification sent via configured channel (Discord, Telegram, etc.)
3. Human approves (`openclaw goal approve <id>`) or rejects (`openclaw goal reject <id>`)
4. On approve: execution resumes. On reject: goal stops.

**Budget Controls:**

| Parameter                | Default      | Description                             |
| ------------------------ | ------------ | --------------------------------------- |
| `maxIterations`          | 20           | Maximum agent iterations                |
| `maxTokens`              | 500000       | Maximum total tokens (input + output)   |
| `maxTimeMs`              | 7200000 (2h) | Maximum wall-clock time                 |
| `providerUsageThreshold` | 80           | Stop if provider usage exceeds this %   |
| `evalEvery`              | 3            | Evaluate every N iterations             |
| `stallThreshold`         | 3            | Consecutive flat evals before stall     |
| `minProgressDelta`       | 5            | Minimum score improvement between evals |
| `consecutiveErrorLimit`  | 3            | Errors before circuit breaker trips     |

**Plugin Configuration:**

```json5
{
  "goal-loop": {
    enabled: true,
    maxConcurrentGoals: 3,
    defaultEvalModel: null, // null = use agent's model
    defaultBudgetIterations: 20,
    defaultBudgetTokens: 500000,
    defaultBudgetTimeMs: 7200000,
    defaultEvalEvery: 3,
    defaultStallThreshold: 3,
    defaultProviderUsageThreshold: 80,
    approvalTimeoutMs: 3600000, // 1 hour timeout for quality gates
    approvalTimeoutAction: "auto-approve",
  },
}
```

**CLI Commands:**

```bash
# Start a goal
openclaw goal start \
  --goal "Build a REST API for user management" \
  --criteria "CRUD operations work" "JWT auth implemented" "Tests pass" \
  --budget-iterations 30 \
  --budget-tokens 1000000 \
  --budget-time 3h \
  --eval-every 5 \
  --quality-gate 10 20 \
  --notify-channel discord \
  --notify-to "CHANNEL_ID"

# Stop a goal
openclaw goal stop abc12345

# Check status
openclaw goal status abc12345

# List all goals
openclaw goal list
openclaw goal list --active

# Resume a stopped/budget-exceeded goal with more budget
openclaw goal resume abc12345 \
  --add-iterations 10 \
  --add-tokens 200000 \
  --add-time 1h

# Approve a quality gate
openclaw goal approve abc12345

# Reject a quality gate
openclaw goal reject abc12345
```

**Data Storage:**

| File                                           | Format | Content                                              |
| ---------------------------------------------- | ------ | ---------------------------------------------------- |
| `~/.openclaw/goal-loop/goals.json`             | JSON   | `{ version: 1, goals: Record<id, GoalState> }`       |
| `~/.openclaw/goal-loop/{id}/iterations.jsonl`  | JSONL  | Per-iteration records (status, summary, duration)    |
| `~/.openclaw/goal-loop/{id}/evaluations.jsonl` | JSONL  | Per-evaluation records (score, criteria, assessment) |

**Example Use Cases:**

1. **Build a project from scratch:** "Build a browser Snake game as a single HTML file" with criteria like "arrow key controls", "score display", "game over screen"
2. **Refactor existing code:** "Refactor the authentication module to use JWT" with criteria tracking specific technical requirements
3. **Write documentation:** "Write comprehensive API docs for the user service" with criteria per endpoint
4. **Research and summarize:** "Research competitor pricing models and write a comparison report" with criteria for depth and coverage

**When to Use Goal Loop vs Planner:**

| Scenario                              | Use Goal Loop           | Use Planner     |
| ------------------------------------- | ----------------------- | --------------- |
| Simple, focused objective             | Yes                     | Overkill        |
| Multi-step with dependencies          | Possible but suboptimal | Yes             |
| Needs parallel execution              | No (sequential)         | Yes             |
| Needs replanning on failure           | No                      | Yes (automatic) |
| Budget-sensitive with stall detection | Yes (built in)          | Limited         |
| Quick tasks (< 10 iterations)         | Yes                     | Yes             |
| Complex projects (20+ steps)          | Stalls often            | Yes             |

---

### 3.2 Planner

**What It Does:**

The Planner extension implements DAG-based task decomposition with parallel worker execution, automatic replanning on failure, and final evaluation scoring. It is designed for complex, multi-step goals that benefit from parallel execution and dependency tracking.

**How It Works:**

```
                              +-----------+
                              |   START   |
                              +-----+-----+
                                    |
                              +-----v-------+
                              |  PLANNING   |
                              | (LLM agent  |
                              |  decomposes |
                              |  into DAG)  |
                              +-----+-------+
                                    |
                              +-----v-------+
                              | VALIDATE    |
                              | DAG         |
                              +-----+-------+
                                    |
                         +----------v-----------+
                         |   EXECUTION LOOP     |
                         |                      |
                         |  1. Governance check  |
                         |  2. Find ready tasks  |
                         |  3. Dispatch workers  |
                         |     (parallel, up to  |
                         |      maxConcurrency)  |
                         |  4. Process results   |
                         |  5. Retry / skip /    |
                         |     replan if needed  |
                         |  6. Update ready set  |
                         +----------+-----------+
                                    |
                         All done / deadlocked
                                    |
                              +-----v-------+
                              | EVALUATING  |
                              | (final LLM  |
                              |  scoring)   |
                              +-----+-------+
                                    |
                              +-----v-------+
                              |   DONE      |
                              | score/100   |
                              +-------------+
```

**Phases:**

| Phase        | Description                                                |
| ------------ | ---------------------------------------------------------- |
| `planning`   | Planner agent decomposes goal into task DAG                |
| `executing`  | Workers execute tasks in parallel, respecting dependencies |
| `replanning` | Replanner agent adjusts task strategy after batch failures |
| `evaluating` | Evaluator agent scores final result against criteria       |
| `done`       | Plan completed with final score                            |

**Task DAG:**

The planner agent produces a directed acyclic graph of tasks. Each task has:

```typescript
interface PlanTask {
  id: string; // e.g., "setup-db"
  title: string; // Human-readable title
  description: string; // Detailed instructions for worker
  status: TaskStatus; // pending | ready | running | completed | failed | skipped
  dependencies: string[]; // IDs of tasks that must complete first
  group?: string; // Optional grouping label
  result?: TaskResult; // Worker output
  retries: number; // Current retry count
  maxRetries: number; // Maximum retries allowed
}
```

**Task Status Flow:**

```
pending -> ready (when all deps completed)
  ready -> running (dispatched to worker)
    running -> completed (worker success)
    running -> ready (worker failed, retries remaining)
    running -> failed (worker failed, max retries)
  pending -> skipped (upstream dependency failed)
```

**Worker Agents:**

Each task is executed by an isolated worker agent (`executor` agent ID) that:

1. Receives the task description and plan context
2. Has access to shell, file, and git tools
3. Executes independently in its own session
4. Returns a `TaskResult` with status, summary, and output

Workers run in parallel up to `maxConcurrency` (default: 3).

**Replanning:**

If the batch failure rate exceeds `replanThreshold` (default: 50%), the orchestrator:

1. Triggers the replanner agent
2. Replanner analyzes completed and failed tasks
3. Produces a revised DAG that keeps completed work and replaces failed/pending tasks
4. Validates the new DAG
5. Resumes execution with the revised plan

**Budget Controls:**

| Parameter         | Default      | Description                                   |
| ----------------- | ------------ | --------------------------------------------- |
| `maxAgentTurns`   | 50           | Total agent turns across all tasks + planning |
| `maxTokens`       | 1000000      | Total token budget                            |
| `maxTimeMs`       | 7200000 (2h) | Wall clock limit                              |
| `maxRetries`      | 2            | Per-task retry limit                          |
| `maxConcurrency`  | 3            | Maximum parallel workers                      |
| `replanThreshold` | 50           | Replan if batch failure rate exceeds this %   |

**Plugin Configuration:**

```json5
{
  planner: {
    enabled: true,
    maxConcurrentPlans: 2,
    defaultMaxAgentTurns: 50,
    defaultMaxTokens: 1000000,
    defaultMaxTimeMs: 7200000,
    defaultMaxConcurrency: 3,
    defaultMaxRetries: 2,
    defaultReplanThreshold: 50,
  },
}
```

**CLI Commands:**

```bash
# Start a plan
openclaw planner start \
  --goal "Build and deploy a user dashboard" \
  --criteria "Authentication works" "CRUD for users" "Responsive UI" "Tests pass" \
  --max-turns 80 \
  --max-tokens 2000000 \
  --max-time 4h \
  --concurrency 4 \
  --max-retries 3 \
  --replan-threshold 40 \
  --notify-channel discord \
  --notify-to "CHANNEL_ID"

# Start from a PRD (Product Requirements Document)
openclaw planner start \
  --goal "Build the project" \
  --from-prd ~/.openclaw/prds/my-project.md

# Stop a plan
openclaw planner stop def67890

# Check status
openclaw planner status def67890

# List all plans
openclaw planner list
openclaw planner list --active

# View task board (kanban view)
openclaw planner tasks def67890

# Resume a stopped/failed plan with more budget
openclaw planner resume def67890 \
  --add-turns 20 \
  --add-tokens 500000 \
  --add-time 2h
```

**Task Board Output Example:**

```
Plan: Build and deploy a user dashboard [def67890]
Status: running | Phase: executing | Revision: 0
Turns: 12/80

--- COMPLETED (3) ---
  [setup-db] Set up database schema (backend) -- PostgreSQL tables created
  [auth-api] Implement authentication API (backend) [deps: setup-db] -- JWT auth working
  [user-crud] User CRUD endpoints (backend) [deps: setup-db] -- All endpoints passing

--- RUNNING (2) ---
  [frontend-auth] Login/signup UI (frontend) [deps: auth-api]
  [frontend-crud] User management UI (frontend) [deps: user-crud]

--- PENDING (1) ---
  [deploy] Deploy to production (devops) [deps: frontend-auth,frontend-crud]
```

**Data Storage:**

| File                                         | Format | Content                                            |
| -------------------------------------------- | ------ | -------------------------------------------------- |
| `~/.openclaw/planner/plans.json`             | JSON   | `{ version: 1, plans: Record<id, PlanState> }`     |
| `~/.openclaw/planner/{id}/tasks.jsonl`       | JSONL  | Task state transition records                      |
| `~/.openclaw/planner/{id}/worker-runs.jsonl` | JSONL  | Worker execution results                           |
| `~/.openclaw/planner/{id}/evaluations.jsonl` | JSONL  | Planning, replanning, and final evaluation records |

**Example Use Cases:**

1. **Full-stack application build:** Decompose into backend setup, API endpoints, frontend components, testing, and deployment tasks
2. **Documentation overhaul:** Break into sections, each handled by a worker, with dependencies for cross-references
3. **Data pipeline setup:** Database, ETL scripts, API layer, monitoring -- each as independent tasks with clear dependencies
4. **Multi-service deployment:** Infrastructure, configuration, deployment, verification tasks running in parallel where possible

**PRD Integration:**

The Planner can load goals and acceptance criteria directly from PRD (Product Requirements Document) files:

```bash
openclaw planner start --goal "Build it" --from-prd ~/.openclaw/prds/my-project.md
```

The PRD parser extracts:

- **Goal** from sections titled "Goal", "Objective", or "Project Goal"
- **Criteria** from sections titled "Acceptance Criteria" or "Success Criteria"

---

### 3.3 Researcher

**What It Does:**

The Researcher extension conducts multi-round interview-driven research to generate complete Product Requirements Documents (PRDs). It alternates between autonomous research (web search, analysis) and human interviews (via Discord buttons or CLI), then synthesizes findings into a structured PRD. Optionally, it can launch the Planner to immediately start building from the generated PRD.

**How It Works:**

```
                              +-----------+
                              |   START   |
                              |  (goal)   |
                              +-----+-----+
                                    |
                         +----------v-----------+
                         |   RESEARCH LOOP      |
                         |                      |
                         |  +---> RESEARCH      |
                         |  |    (agent does    |
                         |  |     web search,   |
                         |  |     analysis)     |
                         |  |        |          |
                         |  |    INTERVIEW      |
                         |  |    (generates     |
                         |  |     questions,    |
                         |  |     waits for     |
                         |  |     user answers) |
                         |  |        |          |
                         |  |  More rounds?     |
                         |  +--- Yes            |
                         |       No             |
                         +----------+-----------+
                                    |
                              +-----v--------+
                              | SYNTHESIZE   |
                              | (generate    |
                              |  full PRD)   |
                              +-----+--------+
                                    |
                              +-----v--------+
                              |   READY      |
                              | (PRD saved,  |
                              |  wait for    |
                              |  "go")       |
                              +-----+--------+
                                    |
                              +-----v--------+
                              |   LAUNCH     |
                              | (start       |
                              |  Planner)    |
                              +--------------+
```

**Research Phases:**

| Phase          | Description                                                   |
| -------------- | ------------------------------------------------------------- |
| `researching`  | Agent conducting autonomous research (web search, analysis)   |
| `interviewing` | Waiting for user to answer generated questions                |
| `synthesizing` | Generating PRD from accumulated research and answers          |
| `ready`        | PRD generated, waiting for user "go" signal to launch planner |
| `launched`     | Planner started from generated PRD                            |
| `stopped`      | Manually stopped                                              |
| `failed`       | Error occurred                                                |

**Research Rounds:**

Each round consists of:

1. **Research phase:** Agent uses web search and analysis tools to gather information about the goal
2. **Interview phase:** Agent generates focused questions based on gaps in knowledge
3. **Answer phase:** User provides answers (via Discord buttons, CLI, or dashboard)

```typescript
interface ResearchRound {
  roundNumber: number; // 0-indexed round
  researchBrief: string; // What the agent discovered
  questions: string[]; // Questions generated for user
  answers: string[]; // User's answers
  researchedAtMs: number; // When research completed
  answeredAtMs?: number; // When answers received
}
```

**Discord Integration:**

When running via Discord, the Researcher sends interview questions as rich embeds with numbered questions. Users can reply directly in the channel, and the extension processes their answers.

```
Researcher: I have 3 questions about your project [abc123]:
  1. What is the primary target audience for this product?
  2. Do you have an existing database or should we design one from scratch?
  3. What is your timeline for the MVP?

Reply: /research-reply abc123 <your answers>
```

**Budget Controls:**

| Parameter            | Default       | Description                       |
| -------------------- | ------------- | --------------------------------- |
| `maxRounds`          | 3             | Maximum research/interview rounds |
| `maxAgentTurns`      | 20            | Agent turn budget                 |
| `maxTokens`          | 200000        | Token budget                      |
| `maxTimeMs`          | 1800000 (30m) | Wall clock limit                  |
| `interviewTimeoutMs` | 3600000 (1h)  | Timeout waiting for user answers  |

**Plugin Configuration:**

```json5
{
  researcher: {
    enabled: true,
    maxConcurrentResearches: 2,
    defaultMaxRounds: 3,
    interviewTimeoutMs: 3600000,
    defaultPlannerBudget: {
      maxAgentTurns: 50,
      maxTokens: 1000000,
      maxTimeMs: 7200000,
      maxConcurrency: 3,
    },
  },
}
```

**CLI Commands:**

```bash
# Start a research session
openclaw researcher start \
  --goal "Build a SaaS invoicing tool for freelancers" \
  --max-rounds 4 \
  --max-turns 30 \
  --max-tokens 300000 \
  --max-time 1h \
  --notify-channel discord \
  --notify-to "CHANNEL_ID"

# Stop a research session
openclaw researcher stop abc12345

# Check status
openclaw researcher status abc12345

# List all research sessions
openclaw researcher list
openclaw researcher list --active

# View generated PRD
openclaw researcher view abc12345
```

**End-to-End Flow:**

1. User starts research: `openclaw researcher start --goal "Build an invoicing SaaS"`
2. Research agent does initial web research on invoicing SaaS products, features, market
3. Interview agent generates 3-5 targeted questions about user preferences, budget, timeline
4. User answers questions via Discord or CLI
5. If more detail needed, loop repeats (up to `maxRounds`)
6. Synthesizer agent generates a complete PRD (markdown file)
7. PRD saved to `~/.openclaw/prds/`
8. User receives notification: "PRD ready! Reply `/research-go abc12345` to start building"
9. On "go", Planner automatically starts with the PRD's goal and criteria

**Data Storage:**

| File                                       | Format   | Content                                                 |
| ------------------------------------------ | -------- | ------------------------------------------------------- |
| `~/.openclaw/researcher/researches.json`   | JSON     | `{ version: 1, researches: Record<id, ResearchState> }` |
| `~/.openclaw/researcher/{id}/rounds.jsonl` | JSONL    | Per-round records (research brief, questions, answers)  |
| `~/.openclaw/prds/*.md`                    | Markdown | Generated PRD documents                                 |

**Example Use Cases:**

1. **New product ideation:** "I want to build a meal planning app" -- Researcher explores the market, asks about dietary preferences, budget, features, then generates a complete PRD
2. **Feature specification:** "Add a collaborative editing feature to our doc tool" -- Researcher explores approaches (OT, CRDT), asks about constraints, generates technical PRD
3. **Market research:** "Should we expand into the European market?" -- Researcher analyzes competitors, regulations, asks about goals, generates strategic document

---

### 3.4 Trend Scout

**What It Does:**

The Trend Scout extension performs autonomous daily monitoring of Hacker News, Reddit, and GitHub for trending topics relevant to configured interests. It fetches items, filters by relevance and score, runs LLM analysis to extract insights and opportunities, stores digests in agent memory, and sends notifications to Discord.

**How It Works:**

```
                              +-----------+
                              |  TRIGGER  |
                              | (daily    |
                              |  9am or   |
                              |  manual)  |
                              +-----+-----+
                                    |
                    +---------------v----------------+
                    |         FETCH SOURCES           |
                    |  +------+  +------+  +-------+ |
                    |  |  HN  |  |Reddit|  |GitHub | |
                    |  |  API |  |OAuth |  |Search | |
                    |  +------+  +------+  +-------+ |
                    +---------------+----------------+
                                    |
                              +-----v------+
                              |  FILTER    |
                              | (relevance,|
                              |  min score,|
                              |  recency)  |
                              +-----+------+
                                    |
                              +-----v------+
                              | DEDUPLICATE|
                              | & RANK     |
                              +-----+------+
                                    |
                              +-----v------+
                              | LLM        |
                              | ANALYSIS   |
                              | (insights, |
                              |  opps)     |
                              +-----+------+
                                    |
                         +----------v-----------+
                         |      OUTPUT          |
                         | +------+ +--------+  |
                         | |Memory| |Discord |  |
                         | |(md)  | |Notify  |  |
                         | +------+ +--------+  |
                         | +------+             |
                         | |JSON  |             |
                         | |digest|             |
                         | +------+             |
                         +----------------------+
```

**Sources:**

| Source          | API                   | What It Fetches                             | Auth Required            |
| --------------- | --------------------- | ------------------------------------------- | ------------------------ |
| **Hacker News** | Firebase API (public) | Top stories, filtered by score and recency  | No                       |
| **Reddit**      | OAuth2 API            | Hot posts from configured subreddits        | Yes (client ID + secret) |
| **GitHub**      | Search API (public)   | Trending repos by language, sorted by stars | No (rate-limited)        |

**Default Configuration:**

```typescript
const DEFAULT_CONFIG: TrendScoutConfig = {
  topics: [
    "ai",
    "llm",
    "agents",
    "typescript",
    "node",
    "react",
    "startup",
    "saas",
    "developer tools",
    "automation",
  ],
  subreddits: [
    "programming",
    "typescript",
    "node",
    "reactjs",
    "MachineLearning",
    "LocalLLaMA",
    "SideProject",
  ],
  languages: ["typescript", "python", "rust", "go"],
  itemsPerSource: 30,
  minScore: 10,
  hoursBack: 24,
};
```

**Trend Item Structure:**

```typescript
interface TrendItem {
  source: "hackernews" | "reddit" | "github";
  title: string;
  url: string;
  score: number;
  comments?: number;
  author?: string;
  timestamp: number;
  description?: string;
  tags?: string[];
}
```

**Trend Digest Structure:**

```typescript
interface TrendDigest {
  date: string; // "2026-02-05"
  generatedAt: number; // timestamp
  topics: string[]; // configured topics
  items: TrendItem[]; // filtered, ranked items
  summary: string; // LLM-generated summary
  insights: string[]; // Key takeaways
  opportunities: string[]; // Actionable opportunities
}
```

**LLM Analysis:**

After fetching and ranking items, the scout sends them to Azure OpenAI for analysis. The LLM produces:

- **Summary:** Overview of the day's trends
- **Key Insights:** Bullet points of notable patterns
- **Opportunities:** Actionable opportunities based on the trends

If the LLM call fails, a fallback analysis is generated suggesting manual review.

**Discord Scout Proposals:**

Trend Scout sends proposals to Discord with interactive buttons:

- **Approve** -- Accept the proposal for action
- **Reject** -- Dismiss the proposal
- **Info** -- Get more information about the trend

These buttons use the spec-based registry pattern to work correctly with Carbon's `ComponentHandler`.

**Memory Integration:**

Each digest is saved to the agent's memory directory as a markdown file (`memory/trends-YYYY-MM-DD.md`). This means:

- Agents can recall past trends via semantic search
- Cross-agent knowledge sharing works through shared memory paths
- Historical trend data accumulates automatically

**Scheduler:**

The Trend Scout runs as a scheduled daily scan (configurable via cron). Default schedule: daily at 9:00 AM local time.

**Data Storage:**

| File                                              | Format   | Content                 |
| ------------------------------------------------- | -------- | ----------------------- |
| `~/.openclaw/dashboard/trend-scout.json`          | JSON     | Configuration overrides |
| `~/.openclaw/dashboard/trend-digests/{date}.json` | JSON     | Daily digest data       |
| `~/.openclaw/workspace/memory/trends-{date}.md`   | Markdown | Digest for agent memory |

---

### 3.5 Agent Packs

**What They Are:**

Agent Packs are pre-configured teams of personality-driven AI agents organized by domain. Each pack contains 3 agents with distinct roles, SOUL personality files, and tool permissions. Packs are defined in a central registry and deployed as a cohesive unit.

**Architecture:**

```
extensions/agent-packs/
  package.json
  openclaw.plugin.json
  src/
    packs-registry.ts    # All pack + agent definitions
    types.ts             # PackDefinition, AgentDefinition types
    soul-loader.ts       # Loads SOUL.md files from packs/ dir
  packs/
    content-creator/
      mia-strategist.md
      blake-scriptwriter.md
      jordan-social.md
    dev-team/
      marcus-techlead.md
      elena-reviewer.md
      sam-docs.md
    solopreneur/
      claire-assistant.md
      leo-researcher.md
      harper-outreach.md
    fitness-training/
      noah-coach.md
      nina-nutrition.md
      ethan-accountability.md
    health-wellness/
      olivia-wellness.md
      mason-sleep.md
      priya-habits.md
    finance-taxes/
      sophia-invoices.md
      liam-expenses.md
      nora-tax.md
```

**Agent Definition Structure:**

```typescript
interface AgentDefinition {
  id: string; // e.g., "mia-strategist"
  name: string; // e.g., "Mia"
  role: string; // e.g., "Content Strategist"
  soulFile: string; // Path to SOUL.md within packs/ dir
  tools: string[]; // Allowed tools: file-read, file-write, exec, web-search, browser
}

interface PackDefinition {
  id: string; // e.g., "content-creator"
  name: string; // e.g., "Content Creator"
  description: string; // What this pack does
  agents: AgentDefinition[];
}
```

**All 6 Packs (Detailed):**

#### Pack 1: Content Creator

**Purpose:** Plan, script, and distribute content across platforms

| Agent  | ID                   | Role                 | Tools                             |
| ------ | -------------------- | -------------------- | --------------------------------- |
| Mia    | `mia-strategist`     | Content Strategist   | file-read, file-write, web-search |
| Blake  | `blake-scriptwriter` | Script Writer        | file-read, file-write             |
| Jordan | `jordan-social`      | Social Media Manager | file-read, file-write, web-search |

**Workflow:** Mia creates content strategy and calendars, delegates scripts to Blake and social posts to Jordan. Mia can spawn Blake and Jordan as sub-agents.

#### Pack 2: Dev Team

**Purpose:** Code review, documentation, and technical leadership

| Agent  | ID                | Role                     | Tools                       |
| ------ | ----------------- | ------------------------ | --------------------------- |
| Marcus | `marcus-techlead` | Tech Lead                | file-read, file-write, exec |
| Elena  | `elena-reviewer`  | Code Reviewer            | file-read, file-write       |
| Sam    | `sam-docs`        | Documentation Specialist | file-read, file-write       |

**Workflow:** Marcus leads technical decisions and can execute shell commands. Elena reviews code for quality. Sam writes and maintains documentation.

#### Pack 3: Solopreneur

**Purpose:** Executive assistance, research, and outreach for solo founders

| Agent  | ID                 | Role                | Tools                             |
| ------ | ------------------ | ------------------- | --------------------------------- |
| Claire | `claire-assistant` | Executive Assistant | file-read, file-write             |
| Leo    | `leo-researcher`   | Research Analyst    | file-read, file-write, web-search |
| Harper | `harper-outreach`  | Outreach Specialist | file-read, file-write, web-search |

**Workflow:** Claire manages scheduling and tasks, Leo handles market research, Harper drafts outreach emails and campaigns.

#### Pack 4: Fitness Training

**Purpose:** Workout programs, nutrition guidance, and accountability

| Agent | ID                     | Role                 | Tools                             |
| ----- | ---------------------- | -------------------- | --------------------------------- |
| Noah  | `noah-coach`           | Training Coach       | file-read, file-write             |
| Nina  | `nina-nutrition`       | Nutrition Coach      | file-read, file-write, web-search |
| Ethan | `ethan-accountability` | Accountability Coach | file-read, file-write             |

**Workflow:** Noah designs workout programs, Nina creates nutrition plans (with web search for recipes/research), Ethan tracks consistency and provides motivation.

#### Pack 5: Health & Wellness

**Purpose:** Sleep optimization, habit building, and wellness routines

| Agent  | ID                | Role           | Tools                 |
| ------ | ----------------- | -------------- | --------------------- |
| Olivia | `olivia-wellness` | Wellness Coach | file-read, file-write |
| Mason  | `mason-sleep`     | Sleep Coach    | file-read, file-write |
| Priya  | `priya-habits`    | Habits Coach   | file-read, file-write |

**Workflow:** Olivia provides holistic wellness guidance, Mason specializes in sleep optimization and routines, Priya helps build and track daily habits.

#### Pack 6: Finance & Taxes

**Purpose:** Invoicing, expense tracking, and tax season preparation

| Agent  | ID                | Role                 | Tools                 |
| ------ | ----------------- | -------------------- | --------------------- |
| Sophia | `sophia-invoices` | Invoicing Specialist | file-read, file-write |
| Liam   | `liam-expenses`   | Expense Tracker      | file-read, file-write |
| Nora   | `nora-tax`        | Tax Season Planner   | file-read, file-write |

**Workflow:** Sophia helps create and manage invoices, Liam categorizes and tracks expenses, Nora helps organize documents for tax filing.

**Pack Configuration:**

```json5
{
  "agent-packs": {
    enabled: true,
    enabledPacks: "all", // or ["content-creator", "dev-team"]
    disabledPacks: [], // packs to exclude even when "all"
  },
}
```

**Adding a New Pack:**

1. Add pack definition to `extensions/agent-packs/src/packs-registry.ts`
2. Create SOUL markdown files in `extensions/agent-packs/packs/{pack-id}/`
3. Add agent entries to `~/.openclaw/openclaw.json` (agents.list + bindings)
4. Create directories: `mkdir -p ~/.openclaw/agents/{id}/sessions ~/.openclaw/workspace-{id}`
5. Copy SOUL files: `cp extensions/agent-packs/packs/{pack}/{agent}.md ~/.openclaw/workspace-{id}/SOUL.md`
6. Rebuild and restart: `pnpm build && systemctl --user restart openclaw-gateway`

---

### 3.6 Automation

**What It Does:**

The Automation extension provides event-driven workflow automation through three mechanisms: webhooks (HTTP callbacks), chains (trigger-to-action rules), and templates (reusable configurations). It enables connecting agent outputs to external systems and triggering follow-up agent workflows automatically.

**Event Types:**

```typescript
type EventType =
  | "goal.started"
  | "goal.completed"
  | "goal.failed"
  | "goal.stalled"
  | "goal.iteration"
  | "plan.started"
  | "plan.completed"
  | "plan.failed"
  | "plan.task.completed"
  | "plan.task.failed"
  | "research.started"
  | "research.completed"
  | "research.round"
  | "system.error";
```

**Event Payload:**

```typescript
interface AutomationEvent {
  type: EventType;
  timestamp: number;
  data: {
    id: string;
    goal?: string;
    status?: string;
    score?: number;
    duration?: number;
    iteration?: number;
    taskId?: string;
    error?: string;
  };
}
```

#### Webhooks

Webhooks send HTTP POST requests to configured URLs when matching events occur.

```typescript
interface Webhook {
  id: string;
  name: string;
  url: string;
  events: EventType[];
  enabled: boolean;
  secret?: string; // HMAC-SHA256 signing
  createdAt: number;
  lastTriggered?: number;
  lastStatus?: number;
}
```

**Webhook Payload:**

```json
{
  "event": "goal.completed",
  "timestamp": 1738764000000,
  "data": {
    "id": "abc12345",
    "goal": "Build a REST API",
    "status": "completed",
    "score": 95,
    "duration": 7200000
  }
}
```

**Headers:**

| Header                 | Value                                  |
| ---------------------- | -------------------------------------- |
| `Content-Type`         | `application/json`                     |
| `User-Agent`           | `OpenClaw-Automation/1.0`              |
| `X-OpenClaw-Event`     | Event type (e.g., `goal.completed`)    |
| `X-OpenClaw-Delivery`  | Unique delivery UUID                   |
| `X-OpenClaw-Signature` | `sha256={hmac}` (if secret configured) |

**Example: Slack notification on goal completion**

```json
{
  "id": "wh-slack-001",
  "name": "Slack Notify",
  "url": "https://hooks.slack.com/services/T00/B00/xxx",
  "events": ["goal.completed", "plan.completed"],
  "enabled": true,
  "secret": "my-signing-secret"
}
```

#### Chains

Chains are trigger-to-action rules that automatically start new agent operations when events occur.

```typescript
interface Chain {
  id: string;
  name: string;
  description: string;
  trigger: {
    type: "goal" | "plan" | "research";
    id?: string; // Specific ID or undefined for any
    event: "completed" | "failed";
    condition?: {
      minScore?: number; // Only trigger if score >= this
      maxScore?: number; // Only trigger if score <= this
    };
  };
  action: {
    type: "goal" | "plan" | "research";
    templateId?: string; // Use a saved template
    config?: {
      goal?: string;
      criteria?: string[];
      budget?: { maxIterations; maxTokens; maxTimeMs };
    };
  };
  enabled: boolean;
  triggeredCount: number;
}
```

**Example: Auto-start plan after research completes**

```json
{
  "id": "chain-001",
  "name": "Research to Plan",
  "description": "Automatically start a plan when research completes",
  "trigger": {
    "type": "research",
    "event": "completed"
  },
  "action": {
    "type": "plan",
    "config": {
      "goal": "Build the researched project"
    }
  },
  "enabled": true,
  "triggeredCount": 0
}
```

**Example: Retry failed goal with more budget**

```json
{
  "id": "chain-002",
  "name": "Retry Failed Goals",
  "description": "If a goal fails with score > 50, retry with more iterations",
  "trigger": {
    "type": "goal",
    "event": "failed",
    "condition": { "minScore": 50 }
  },
  "action": {
    "type": "goal",
    "config": {
      "budget": { "maxIterations": 30, "maxTokens": 1000000 }
    }
  },
  "enabled": true,
  "triggeredCount": 0
}
```

#### Templates

Templates are reusable configurations for starting goals, plans, or research sessions.

```typescript
interface Template {
  id: string;
  name: string;
  description: string;
  type: "goal" | "plan" | "research";
  config: {
    goal?: string;
    criteria?: string[];
    budget?: {
      maxIterations?: number;
      maxTokens?: number;
      maxTimeMs?: number;
      evalEvery?: number;
    };
  };
}
```

**Example Template:**

```json
{
  "id": "tpl-quick-build",
  "name": "Quick Build",
  "description": "Fast goal execution with tight budget",
  "type": "goal",
  "config": {
    "budget": {
      "maxIterations": 10,
      "maxTokens": 200000,
      "maxTimeMs": 1800000,
      "evalEvery": 3
    }
  }
}
```

**Data Storage:**

| File                                   | Content              |
| -------------------------------------- | -------------------- |
| `~/.openclaw/dashboard/webhooks.json`  | Webhook definitions  |
| `~/.openclaw/dashboard/chains.json`    | Chain definitions    |
| `~/.openclaw/dashboard/templates.json` | Template definitions |

---

## 4. Mission Control Dashboard

### Overview

The Mission Control Dashboard is a local-first Next.js web application that provides real-time monitoring and control for all agent operations in OpenClawd. It reads state directly from the filesystem (`~/.openclaw/`) and executes commands via CLI or Gateway API. No external database is required.

**Key Facts:**

- **Location:** `~/projects/openclawd-dashboard`
- **URL:** `http://localhost:3000` (local only, NEVER deploy publicly)
- **Tech Stack:** Next.js 16, React 19, Tailwind CSS 4, TypeScript
- **Theme:** Ocean/Kitesurf color palette (Mistral Wind)
- **Auto-refresh:** 5-second polling when active missions exist

### Architecture

```
Browser (http://localhost:3000)
    |
    +--- Next.js App Router (Server Components)
    |     |
    |     +--- Server Actions (CLI execution)
    |     |     |
    |     |     +--- openclaw goal start/stop/resume
    |     |     +--- openclaw planner start/stop/resume
    |     |     +--- openclaw researcher start/stop
    |     |
    |     +--- Data Layer (filesystem reads)
    |           |
    |           +--- ~/.openclaw/goal-loop/goals.json
    |           +--- ~/.openclaw/planner/plans.json
    |           +--- ~/.openclaw/researcher/researches.json
    |           +--- ~/.openclaw/openclaw.json
    |           +--- ~/.openclaw/prds/*.md
    |           +--- ~/.openclaw/cron/jobs.json
    |           +--- ~/.openclaw/dashboard/*.json
    |
    +--- Gateway API (port 18789)
          |
          +--- POST /researcher/answer
          +--- POST /researcher/go
```

### Pages

| Route          | Page               | Description                                                         |
| -------------- | ------------------ | ------------------------------------------------------------------- |
| `/command`     | **Command Center** | Unified Kanban board for all missions (goals, plans, research)      |
| `/`            | (redirect)         | Redirects to `/command`                                             |
| `/goals`       | (redirect)         | Redirects to `/command?type=goal`                                   |
| `/goals/[id]`  | **Goal Detail**    | Iteration timeline, evaluation history, criteria status             |
| `/plans`       | (redirect)         | Redirects to `/command?type=plan`                                   |
| `/plans/[id]`  | **Plan Detail**    | Task Kanban board, DAG visualization, budget gauges, phase stepper  |
| `/research`    | (redirect)         | Redirects to `/command?type=research`                               |
| `/prds`        | **PRDs**           | Product Requirement Documents rendered as markdown                  |
| `/agents`      | **Agents**         | Agent list, workspace info, session stats, SOUL.md viewer           |
| `/agents/[id]` | **Agent Detail**   | Full agent config, binding info, workspace files, recent tool calls |
| `/analytics`   | **Analytics**      | Daily usage charts, cost breakdown, performance metrics             |
| `/automation`  | **Automation**     | Templates, webhooks, chained execution rules                        |
| `/cron`        | **Cron**           | Scheduled jobs, enable/disable toggle, next run times               |
| `/system`      | **System**         | Gateway config, plugin status, registered agents                    |
| `/security`    | **Security**       | Security settings, allowlists, policy review                        |
| `/trends`      | **Trends**         | Trend tracking and analysis (if trend-scout enabled)                |

### Command Center (Kanban Board)

The central page of the dashboard, providing a unified view of all agent operations:

**5-Column Kanban:**

| Column      | Statuses Mapped                                                   |
| ----------- | ----------------------------------------------------------------- |
| **Backlog** | `stopped` (resumable)                                             |
| **Active**  | `running`, `planning`, `executing`, `researching`, `synthesizing` |
| **Review**  | `interviewing`, `ready` (awaiting input)                          |
| **Done**    | `completed`, `done`, `launched`                                   |
| **Failed**  | `failed`, `budget_exceeded`                                       |

**Mission Card Display:**

Each card shows:

- Type icon (goal/plan/research) and ID
- Title (truncated to fit)
- Progress bar
- Priority badge (Critical/High/Medium/Low)
- Score (if available)
- Error indicator
- Time since last update

**Interactive Controls:**

- "+ New" button expands forms for starting goals/plans/research
- Stop/Abandon buttons on running executions
- Resume buttons for stalled/stopped items
- "Launch Plan" for completed research sessions
- Type filter toggles: All / Goals / Plans / Research

**Agent Queues Sidebar:**

Shows work assigned to each agent (which goals/plans are using which agents).

**Activity Feed:**

Collapsible timeline showing recent events across all operations.

### Plan Detail Page

The plan detail page provides rich visualization of plan execution:

- **Phase Stepper:** Visual pipeline with CSS pulse animation on current phase (planning -> executing -> replanning -> evaluating -> done)
- **Task Board:** 6-column kanban (pending / ready / running / completed / failed / skipped) showing individual task cards with dependency info
- **Task DAG:** SVG dependency graph with BFS layout, status-colored nodes, and connection lines
- **Budget Gauges:** Horizontal progress bars for agent turns, tokens, and time usage
- **Criteria Checklist:** Final evaluation with met/unmet indicators for each criterion

### Keyboard Shortcuts

| Shortcut | Action               |
| -------- | -------------------- |
| `g c`    | Go to Command Center |
| `g a`    | Go to Analytics      |
| `g s`    | Go to System         |
| `g t`    | Go to Agents         |
| `g u`    | Go to Automation     |
| `/`      | Open global search   |
| `?`      | Show shortcuts help  |

### Theme

Ocean/Kitesurf color palette (Mistral Wind theme):

| Token          | Hex       | Usage                 |
| -------------- | --------- | --------------------- |
| bg-primary     | `#0a141e` | Deep ocean background |
| bg-secondary   | `#0f1f2e` | Cards, panels         |
| border         | `#1e3a4f` | All borders           |
| text-primary   | `#e8f4fa` | Headings, body text   |
| text-secondary | `#7a9bb0` | Labels, muted text    |
| accent-cyan    | `#22d3ee` | Active/in-progress    |
| accent-teal    | `#00d4aa` | Success/completed     |
| accent-coral   | `#fb923c` | Warning/paused        |

### Running the Dashboard

```bash
cd ~/projects/openclawd-dashboard
npm install
npm run dev
# Open http://localhost:3000
```

---

## 5. Agent System Details

### 5.1 Agent Components

Every agent in OpenClawd consists of four core components:

#### Configuration (in `~/.openclaw/openclaw.json`)

```json5
{
  agents: {
    list: [
      {
        id: "mia-strategist", // Unique ID
        workspace: "/home/user/.openclaw/workspace-mia-strategist", // Isolated workspace
        identity: {
          name: "Mia",
          emoji: "",
        },
        // Optional: sub-agent delegation
        subagents: {
          allowAgents: ["blake-scriptwriter", "jordan-social"],
        },
      },
    ],
  },
}
```

#### Sessions (`~/.openclaw/agents/{id}/sessions/*.jsonl`)

Each agent maintains its own session history as JSONL files:

- Every message, tool call, and response is logged
- Sessions are isolated per agent -- no cross-agent leakage
- Used for memory indexing and dashboard display
- Session files grow over time; old sessions can be archived

#### Workspace (`~/.openclaw/workspace-{id}/`)

Isolated file storage for each agent:

- Agents can only read/write within their workspace
- Contains `SOUL.md`, `MEMORY.md`, and any files the agent creates
- Goal Loop and Planner iterations operate within the workspace
- Can contain git repositories for code projects

#### SOUL (`{workspace}/SOUL.md`)

The SOUL file defines the agent's personality, responsibilities, and behavior:

```markdown
# Mia -- Content Strategist

You are Mia, a content strategist who develops comprehensive content plans
and coordinates creative teams.

## Core Philosophy

- Content is king, but strategy is the kingdom
- Data-driven decisions with creative execution
- Consistency builds audience; surprise keeps them engaged

## Your Responsibilities

### 1. Content Strategy

- Develop quarterly content calendars
- Identify trending topics and content gaps
- Define content pillars and brand voice guidelines

### 2. Team Coordination

- Delegate script writing to Blake
- Brief Jordan on social media campaigns
- Review and approve final deliverables

## How You Work

- Communication style: Professional yet creative, uses data to back ideas
- Decision-making: Research-first, then creative brainstorm
- Collaboration: Delegates clearly, provides constructive feedback

## Tools You Use

- File read/write: Content calendars, briefs, strategy docs
- Web search: Trend research, competitor analysis

## Output Style

- Use markdown tables for calendars
- Bullet points for action items
- Include metrics targets for each content piece
```

### 5.2 Multi-Agent Communication

Agents can communicate with each other through two built-in tools:

#### sessions_spawn (Parent -> Child delegation)

```
User -> Mia: "Create a content campaign for summer sale"
Mia (thinking): "I need scripts from Blake and social posts from Jordan"

Mia -> sessions_spawn(
  agentId: "blake-scriptwriter",
  task: "Write 3 video scripts for summer sale campaign. Theme: beach vibes.
         Each script should be 60 seconds. Include B-roll suggestions."
)

Blake runs in isolation, writes scripts, saves to workspace
Blake -> announces results back to Mia's session

Mia -> sessions_spawn(
  agentId: "jordan-social",
  task: "Create 10 social media posts promoting summer sale.
         Use hashtags #SummerSale #BeachVibes. Platform mix: 4 Instagram, 3 Twitter, 3 TikTok."
)

Jordan runs in isolation, writes posts, saves to workspace
Jordan -> announces results back to Mia's session

Mia -> User: "Campaign ready! Blake wrote 3 video scripts and Jordan created 10 social posts."
```

#### sessions_send (Any -> Any messaging)

Allows sending a message to any existing session. Used for follow-up queries or updates.

#### Subagent Allowlists

Control which agents can spawn which via configuration:

```json5
{
  agents: {
    list: [
      {
        id: "mia-strategist",
        subagents: {
          allowAgents: ["blake-scriptwriter", "jordan-social"],
        },
      },
      {
        id: "marcus-techlead",
        subagents: {
          allowAgents: ["elena-reviewer", "sam-docs"],
        },
      },
    ],
  },
}
```

#### Visibility Policies

| Policy              | Description                                          |
| ------------------- | ---------------------------------------------------- |
| `spawned` (default) | Agent can only communicate with subagents it spawned |
| `unrestricted`      | Agent can message any session (use with caution)     |

### 5.3 Persistent Memory

Each agent has persistent semantic memory powered by vector embeddings and SQLite.

**What Gets Indexed:**

| Source             | Description                                                                 |
| ------------------ | --------------------------------------------------------------------------- |
| `MEMORY.md`        | Agent's workspace memory file (user preferences, project history, contacts) |
| `sessions/*.jsonl` | Past conversation transcripts and tool call results                         |

**How It Works:**

1. **Sync:** On session start, the agent's memory index syncs (indexes new content from MEMORY.md and recent sessions)
2. **Search:** During conversation, agents can semantically search past context using natural language queries
3. **Automatic:** No explicit "remember" command needed -- everything is indexed automatically
4. **Configurable:** Sync interval, max results, minimum similarity score are all configurable

**Memory Configuration:**

```json5
{
  agents: {
    defaults: {
      memorySearch: {
        enabled: true,
        sources: ["memory", "sessions"],
        provider: "openai", // Embedding provider
        sync: {
          onSessionStart: true, // Sync when conversation starts
          watchEnabled: true, // Watch for file changes
          intervalMinutes: 60, // Periodic re-index
        },
        query: {
          maxResults: 10, // Maximum search results
          minScore: 0.5, // Minimum similarity threshold
        },
      },
    },
  },
}
```

**Memory Isolation:**

Each agent has completely isolated memory. Agents cannot search each other's memories unless explicitly configured with shared `extraPaths`:

```json5
{
  agents: {
    defaults: {
      memorySearch: {
        extraPaths: [
          "~/.openclaw/workspace/memory/knowledge/", // Shared knowledge base
        ],
      },
    },
  },
}
```

**Shared Knowledge Base:**

The system includes a shared knowledge directory at `~/.openclaw/workspace/memory/knowledge/` that all agents can access. This enables:

- Research findings shared across agents
- Scout notes visible to the nightly improvement scanner
- Cross-agent learning without breaking memory isolation

**Adding Persistent Notes:**

Create or edit `~/.openclaw/workspace-{agent}/MEMORY.md`:

```markdown
# Agent Memory

## User Preferences

- Prefers concise responses
- Timezone: EST
- Communication style: direct

## Past Projects

- Summer 2025: Launched product X (score: 95/100)
- Q1 2026: Rebranded to Y (completed via planner)

## Important Contacts

- Designer: Sarah (sarah@example.com)
- Developer: Mike (prefers Slack)
```

### 5.4 Creating Custom Agents

#### Approach 1: Agent Packs (Recommended for teams)

See [Section 3.5: Agent Packs](#35-agent-packs) for the full pack creation workflow.

**Summary:**

1. Define pack in `extensions/agent-packs/src/packs-registry.ts`
2. Create SOUL markdown files in `extensions/agent-packs/packs/{pack-id}/`
3. Add agents and bindings to `~/.openclaw/openclaw.json`
4. Create workspace and session directories
5. Copy SOUL files to workspaces
6. Rebuild and restart gateway

#### Approach 2: Standalone Agents

For one-off or custom agents:

```bash
# 1. Create directories
mkdir -p ~/.openclaw/workspace-myagent
mkdir -p ~/.openclaw/agents/myagent/sessions

# 2. Create SOUL.md
cat > ~/.openclaw/workspace-myagent/SOUL.md << 'EOF'
# MyAgent

You are MyAgent, specialized in [domain].

## Instructions
- How to behave
- What to focus on
- Constraints and guidelines
EOF

# 3. Add to config (openclaw.json)
# agents.list: { id: "myagent", workspace: "...", identity: { name: "MyAgent", emoji: "..." } }
# bindings: { agentId: "myagent", match: { channel: "discord", peer: { id: "CHANNEL_ID" } } }

# 4. Restart gateway
systemctl --user restart openclaw-gateway
```

### 5.5 Routing and Bindings

Messages are routed to agents based on static bindings:

```json5
{
  bindings: [
    {
      agentId: "mia-strategist",
      match: {
        channel: "discord",
        peer: { id: "1468554279093669888" }, // Discord channel ID
      },
    },
  ],
}
```

**Binding Priority (highest to lowest):**

1. Exact peer match (specific channel ID)
2. Parent peer match (thread inherits parent channel's agent)
3. Guild match (server-wide fallback)
4. Team match (workspace fallback, Slack)
5. Account match (account-wide fallback)
6. Default agent (`main`)

**Ack Reactions:**

When an agent receives a message, it immediately reacts with its emoji (e.g., Mia reacts with "") before processing. This provides instant visual feedback about which agent is handling the request.

---

## 6. Security Model

### 6.1 Security Posture Overview

| Layer                 | Setting                                 | Status                                |
| --------------------- | --------------------------------------- | ------------------------------------- |
| **Gateway binding**   | Loopback only (127.0.0.1)               | Active -- not accessible from network |
| **Gateway auth**      | Token required for API calls            | Active                                |
| **Discord policy**    | Allowlist (only approved users)         | Active                                |
| **Browser sandbox**   | `noSandbox: false`                      | Enabled                               |
| **Secrets isolation** | Separate file, chmod 600                | Active                                |
| **Workspace scoping** | Each agent restricted to own workspace  | Active                                |
| **Memory isolation**  | Per-agent SQLite, no cross-agent access | Active                                |

### 6.2 Gateway Binding

The gateway binds exclusively to the loopback interface (`127.0.0.1:18789`). This means:

- No external network access to the gateway
- Only local processes can communicate with it
- Dashboard (localhost:3000) can reach it
- CLI commands can reach it
- External access requires explicit tunneling (SSH, Tailscale, etc.)

```json5
{
  gateway: {
    bind: "loopback", // Only 127.0.0.1
    port: 18789,
  },
}
```

### 6.3 Token Authentication

All API calls to the gateway require a bearer token:

```json5
{
  gateway: {
    auth: {
      token: "your-secure-token-here",
    },
  },
}
```

The token is set in the config file and must be provided in the `Authorization` header for HTTP requests.

### 6.4 Discord Allowlist Policy

Discord bot access is restricted to an allowlist of approved user IDs:

```json5
{
  discord: {
    policy: "allowlist",
    allowedUsers: ["USER_ID_1", "USER_ID_2"],
  },
}
```

Only users on the allowlist can interact with the bot. All other messages are ignored.

### 6.5 Browser Sandbox

The Puppeteer/Chrome browser used by agents runs in sandbox mode by default:

```json5
{
  browser: {
    noSandbox: false, // Sandbox ENABLED (default)
    stealth: true, // Anti-bot detection evasion
  },
}
```

The stealth browser feature (fork addition) uses fingerprint generation and injection to avoid bot detection on sites like Booking.com and Airbnb.

### 6.6 Secrets Isolation

Secrets are stored in a separate file with restricted permissions:

```bash
~/.openclaw/.secrets.env  (chmod 600)

# Contents:
AZURE_OPENAI_API_KEY=...
DISCORD_BOT_TOKEN=...
NOTION_API_KEY=...
OPENCLAW_GATEWAY_TOKEN=...
REDDIT_CLIENT_SECRET=...
```

This file is:

- NOT in the git repository
- Readable only by the owner (chmod 600)
- Loaded by the gateway at startup
- Not accessible to agents via file tools

### 6.7 Workspace Scoping

Each agent can only read and write files within its designated workspace:

| Agent Tool   | Scope                               |
| ------------ | ----------------------------------- |
| `file-read`  | Agent's workspace only              |
| `file-write` | Agent's workspace only              |
| `exec`       | Runs in agent's workspace directory |
| `browser`    | Sandboxed Chrome instance           |
| `git`        | Scoped to workspace                 |

System agents used by extensions (planner, executor, qa, researcher) have workspace access appropriate to their function.

### 6.8 Webhook Security

Outgoing webhooks support HMAC-SHA256 payload signing:

```json
{
  "secret": "your-webhook-secret"
  // Payloads include X-OpenClaw-Signature header:
  // sha256={hmac_of_body}
}
```

Recipients can verify webhook authenticity by computing the HMAC and comparing signatures.

---

## 7. Quick Start Guide

### 7.1 Prerequisites

| Requirement      | Version | Notes                                          |
| ---------------- | ------- | ---------------------------------------------- |
| **Node.js**      | 22+     | Runtime for gateway and CLI                    |
| **pnpm**         | 9+      | Package manager (recommended over npm)         |
| **Git**          | 2.x     | For cloning and version control                |
| **Discord Bot**  | --      | Created in Discord Developer Portal (optional) |
| **Azure OpenAI** | --      | Or any OpenAI-compatible API endpoint          |

### 7.2 Installation

```bash
# 1. Clone the repository
git clone https://github.com/2positiveclawd/openclaw.git
cd openclaw

# 2. Install dependencies
pnpm install

# 3. Build the project
pnpm build

# 4. Install the gateway service
pnpm openclaw service install
```

### 7.3 Configuration

Create the main config file at `~/.openclaw/openclaw.json`:

```json5
{
  // LLM Provider (Azure OpenAI example)
  models: {
    providers: {
      azure: {
        baseUrl: "https://your-deployment.openai.azure.com/openai",
        apiKey: "YOUR_API_KEY",
        models: [{ id: "gpt-5-mini", alias: "default" }],
      },
    },
  },

  // Gateway settings
  gateway: {
    mode: "local",
    port: 18789,
    bind: "loopback",
    auth: {
      token: "your-gateway-token",
    },
  },

  // Enable extensions
  "goal-loop": { enabled: true },
  planner: { enabled: true },
  researcher: { enabled: true },
  "trend-scout": { enabled: true },
  "agent-packs": { enabled: true },
  automation: { enabled: true },

  // Agents
  agents: {
    list: [
      {
        id: "main",
        workspace: "~/.openclaw/workspace",
        identity: { name: "Main", emoji: "" },
      },
    ],
    defaults: {
      memorySearch: {
        enabled: true,
        sources: ["memory", "sessions"],
        provider: "openai",
      },
    },
  },

  // Bindings (Discord example)
  bindings: [
    {
      agentId: "main",
      match: {
        channel: "discord",
        peer: { id: "YOUR_DISCORD_CHANNEL_ID" },
      },
    },
  ],
}
```

Create secrets file at `~/.openclaw/.secrets.env`:

```bash
AZURE_OPENAI_API_KEY=your-azure-api-key
DISCORD_BOT_TOKEN=your-discord-bot-token
chmod 600 ~/.openclaw/.secrets.env
```

Create required directories:

```bash
mkdir -p ~/.openclaw/agents/main/sessions
mkdir -p ~/.openclaw/workspace
mkdir -p ~/.openclaw/goal-loop
mkdir -p ~/.openclaw/planner
mkdir -p ~/.openclaw/researcher
mkdir -p ~/.openclaw/prds
mkdir -p ~/.openclaw/dashboard
```

### 7.4 Starting the Gateway

```bash
# Start via systemd (recommended)
systemctl --user start openclaw-gateway

# Verify it's running
systemctl --user status openclaw-gateway

# Check port
ss -ltnp | grep 18789

# View logs
journalctl --user -u openclaw-gateway -f
```

### 7.5 Connecting Discord

1. **Create a Discord Application:** Go to https://discord.com/developers/applications
2. **Create a Bot:** Under your application, go to Bot tab, click "Add Bot"
3. **Copy Token:** Copy the bot token to `~/.openclaw/.secrets.env` as `DISCORD_BOT_TOKEN`
4. **Set Permissions:** Enable Message Content Intent under Bot settings
5. **Invite Bot:** Generate invite URL with these permissions: Send Messages, Read Message History, Add Reactions, Use Application Commands
6. **Configure Channel:** Get the channel ID (Developer Mode -> Right-click channel -> Copy ID) and add it to your bindings in `openclaw.json`
7. **Restart Gateway:** `systemctl --user restart openclaw-gateway`
8. **Test:** Send a message in the Discord channel -- the bot should respond

### 7.6 Running Your First Goal

```bash
# Start a simple goal
openclaw goal start \
  --goal "Create a README.md file that explains how to use this project" \
  --criteria "Has installation instructions" "Has usage examples" "Has API reference" \
  --budget-iterations 10 \
  --budget-tokens 200000 \
  --budget-time 30m

# Watch progress (read state file directly)
cat ~/.openclaw/goal-loop/goals.json | python3 -m json.tool | tail -30

# Or use the dashboard
cd ~/projects/openclawd-dashboard && npm run dev
# Open http://localhost:3000/command
```

### 7.7 Running Your First Plan

```bash
# Start a plan with multiple parallel tasks
openclaw planner start \
  --goal "Build a simple todo list web application" \
  --criteria "HTML/CSS frontend" "JavaScript interactivity" "Local storage persistence" "Responsive design" \
  --max-turns 30 \
  --max-tokens 500000 \
  --max-time 1h \
  --concurrency 3

# View task board
openclaw planner tasks <plan-id>

# Watch progress via dashboard
# http://localhost:3000/plans/<plan-id>
```

### 7.8 Running Your First Research Session

```bash
# Start a research session
openclaw researcher start \
  --goal "I want to build a SaaS tool for freelance invoice management" \
  --max-rounds 3 \
  --notify-channel discord \
  --notify-to "YOUR_CHANNEL_ID"

# The researcher will:
# 1. Research the market automatically
# 2. Send you interview questions via Discord
# 3. Wait for your answers
# 4. Generate a PRD
# 5. Wait for your "go" signal to launch the planner
```

---

## 8. Feature Comparison Table

### OpenClawd vs Other AI Agent Systems

| Feature                         | OpenClawd                                                                   | ChatGPT (Operator/Custom GPTs) | AutoGPT      | CrewAI            | LangGraph     | MetaGPT        |
| ------------------------------- | --------------------------------------------------------------------------- | ------------------------------ | ------------ | ----------------- | ------------- | -------------- |
| **Self-hosted**                 | Yes (local-first)                                                           | No (cloud)                     | Yes          | Yes               | Yes           | Yes            |
| **Multi-agent support**         | 24 agents with isolation                                                    | Limited (custom GPTs)          | Single agent | Yes (crews)       | Yes (graphs)  | Yes (roles)    |
| **Agent isolation**             | Full (workspace, memory, sessions)                                          | None                           | None         | Partial           | Partial       | Partial        |
| **Persistent memory**           | Vector embeddings + SQLite                                                  | Limited context window         | File-based   | No built-in       | No built-in   | No built-in    |
| **Budget governance**           | Comprehensive (tokens, time, iterations, stall detection, circuit breakers) | Token limits only              | Token limits | No built-in       | No built-in   | No built-in    |
| **DAG task planning**           | Yes (Planner extension)                                                     | No                             | No           | Sequential        | Yes (custom)  | Yes            |
| **Parallel execution**          | Yes (configurable concurrency)                                              | No                             | No           | Yes               | Yes           | Yes            |
| **Auto-replanning**             | Yes (on batch failure)                                                      | No                             | No           | No                | Manual        | No             |
| **Interview-driven PRDs**       | Yes (Researcher extension)                                                  | No                             | No           | No                | No            | No             |
| **Trend monitoring**            | Yes (Trend Scout)                                                           | No                             | No           | No                | No            | No             |
| **Pre-built agent teams**       | 6 packs, 18 agents                                                          | Custom GPTs (marketplace)      | No           | Community         | No            | Built-in roles |
| **Discord integration**         | Native (Carbon SDK)                                                         | No                             | Community    | No                | No            | No             |
| **Dashboard**                   | Local-first Kanban                                                          | Web UI                         | Terminal     | Terminal          | LangSmith     | No             |
| **Webhooks**                    | Yes                                                                         | No                             | No           | No                | No            | No             |
| **Event chains**                | Yes (trigger-to-action)                                                     | No                             | No           | No                | No            | No             |
| **Quality gates**               | Yes (human-in-the-loop)                                                     | No                             | No           | No                | Yes (custom)  | No             |
| **Stall detection**             | Yes (evaluation score plateau)                                              | No                             | No           | No                | No            | No             |
| **Provider usage monitoring**   | Yes (threshold-based stop)                                                  | No                             | No           | No                | No            | No             |
| **Agent personalities (SOULs)** | Rich markdown with tools, style, responsibilities                           | System prompts                 | Prompt files | Role descriptions | State schemas | Role cards     |
| **Cost**                        | Free (self-hosted) + LLM API costs                                          | $20-200/mo subscription        | Free + API   | Free + API        | Free + API    | Free + API     |
| **Open source**                 | Fork of MIT-licensed OpenClaw                                               | No                             | Yes (MIT)    | Yes (MIT)         | Yes (MIT)     | Yes (MIT)      |
| **Tool access**                 | Shell, files, git, browser, web search                                      | Limited (browsing, code)       | Shell, files | Custom tools      | Custom tools  | Custom tools   |
| **Notification channels**       | Discord, Telegram, Slack, WhatsApp, Signal                                  | None                           | None         | None              | None          | None           |

### When to Choose OpenClawd

**Choose OpenClawd if you need:**

- Self-hosted agents with no data leaving your infrastructure
- Comprehensive budget controls to prevent runaway API costs
- Pre-built agent teams for specific domains (content, dev, fitness, etc.)
- Interview-driven requirements gathering that generates actionable PRDs
- Autonomous goal execution with evaluation, stall detection, and quality gates
- A unified dashboard to monitor all agent operations
- Event-driven automation connecting agent outputs to external systems
- Persistent semantic memory that survives across conversations

**Consider alternatives if you need:**

- Zero-setup cloud solution (ChatGPT, Claude)
- Deeply customizable graph-based agent flows (LangGraph)
- Large community of pre-built integrations (LangChain ecosystem)
- Enterprise SSO and team management (proprietary platforms)

---

## 9. Pricing and Licensing Considerations

### 9.1 Open Source Base

OpenClawd is built on **OpenClaw**, which is released under the **MIT License**. The base gateway, CLI, plugin system, and channel integrations (Discord, Telegram, Slack, WhatsApp, Signal, iMessage) are all open source and free to use.

### 9.2 Fork Extensions

The six custom extensions developed for OpenClawd are not currently part of upstream OpenClaw. They represent proprietary innovation built on top of the open-source platform:

| Extension   | Lines of Code | Proprietary Value                                   |
| ----------- | ------------- | --------------------------------------------------- |
| Goal Loop   | ~2,500        | Autonomous goal execution with governance           |
| Planner     | ~2,800        | DAG-based task decomposition and parallel execution |
| Researcher  | ~2,700        | Interview-driven PRD generation                     |
| Trend Scout | ~1,700        | Autonomous trend monitoring                         |
| Agent Packs | ~1,200        | Pre-built personality agent teams                   |
| Automation  | ~1,000        | Event-driven webhooks and chains                    |
| **Total**   | **~12,000**   | **Full autonomous agent orchestration platform**    |

Additionally, ~85 lines of core patches, the component registry (~82 lines), and the browser stealth module (~162 lines) add unique value.

### 9.3 Suggested Pricing Tiers

Based on the feature set and target audience, these pricing tiers would position OpenClawd competitively:

#### Free / Community Tier

- **What:** OpenClaw base (MIT) with basic agent support
- **Agents:** 1 default agent
- **Extensions:** None (Goal Loop, Planner, etc. not included)
- **Dashboard:** Not included
- **Support:** Community (GitHub Issues, Discord)
- **Price:** Free (open source)

#### Starter Tier

- **What:** Base + Goal Loop + 1 Agent Pack
- **Agents:** Up to 6 (1 system + 1 pack of 3 + custom)
- **Extensions:** Goal Loop, Agent Packs (1 pack)
- **Dashboard:** Included
- **Budget controls:** Full governance suite
- **Support:** Email
- **Price:** $29/month (or $290/year)

#### Pro Tier

- **What:** Full extension suite
- **Agents:** Up to 24 (all packs + custom)
- **Extensions:** Goal Loop, Planner, Researcher, Trend Scout, Agent Packs (all), Automation
- **Dashboard:** Full (all pages)
- **Features:** Webhooks, chains, templates, multi-agent communication
- **Support:** Priority email + Discord
- **Price:** $79/month (or $790/year)

#### Enterprise Tier

- **What:** Everything + deployment support + custom extensions
- **Agents:** Unlimited
- **Extensions:** All + custom development
- **Dashboard:** Full + custom pages
- **Features:** Everything in Pro + SSO, team management, audit logs
- **Deployment:** Docker, Kubernetes, on-premise support
- **Support:** Dedicated Slack channel, SLA
- **Price:** Custom (starting at $499/month)

#### Self-Hosted / Bring Your Own License

- **What:** All source code, deploy yourself
- **Price:** One-time $999 or $199/year for updates
- **Note:** Requires own LLM API keys (Azure OpenAI, OpenAI, etc.)

### 9.4 Cost Structure for End Users

The main operating cost for OpenClawd users is LLM API usage. Estimated costs per operation type:

| Operation                         | Typical Token Usage        | Estimated Cost (GPT-4o-mini) | Estimated Cost (GPT-4o) |
| --------------------------------- | -------------------------- | ---------------------------- | ----------------------- |
| **Single agent chat**             | 5K-20K tokens/conversation | $0.01-0.05                   | $0.05-0.20              |
| **Goal Loop (10 iterations)**     | 100K-300K tokens total     | $0.15-0.45                   | $0.50-1.50              |
| **Planner (20 tasks, 3 workers)** | 500K-1M tokens total       | $0.75-1.50                   | $2.50-5.00              |
| **Research session (3 rounds)**   | 50K-150K tokens            | $0.08-0.23                   | $0.25-0.75              |
| **Trend Scout (daily)**           | 10K-30K tokens             | $0.02-0.05                   | $0.05-0.15              |
| **Full day of moderate usage**    | 1M-3M tokens               | $1.50-4.50                   | $5.00-15.00             |

**Note:** These are rough estimates. Actual costs depend on:

- Model choice (smaller models are cheaper)
- Goal/plan complexity
- Number of iterations before completion
- Agent conversation length
- Evaluation frequency

### 9.5 Competitive Positioning

| Competitor        | Monthly Cost | What You Get                                                    |
| ----------------- | ------------ | --------------------------------------------------------------- |
| ChatGPT Plus      | $20/mo       | 1 agent, cloud-only, no customization                           |
| ChatGPT Team      | $25/mo/user  | Teams features, limited agents                                  |
| Claude Pro        | $20/mo       | 1 agent, cloud-only                                             |
| GitHub Copilot    | $10-39/mo    | Code-only, no autonomous agents                                 |
| AutoGPT Cloud     | $20-100/mo   | Single agent, limited governance                                |
| **OpenClawd Pro** | **$79/mo**   | **24 agents, full orchestration, self-hosted, unlimited usage** |

The key value proposition: **With OpenClawd, you pay for the platform once and only pay per-token for LLM usage. No per-seat, per-agent, or per-message fees.** A team of 24 AI agents at $79/month is dramatically cheaper than any cloud AI agent platform.

---

## Appendix A: Complete Data File Reference

| File                                              | Extension    | Format   | Content                                                   |
| ------------------------------------------------- | ------------ | -------- | --------------------------------------------------------- |
| `~/.openclaw/openclaw.json`                       | All          | JSON5    | Main configuration (agents, bindings, plugins, providers) |
| `~/.openclaw/.secrets.env`                        | All          | env      | API keys and secrets                                      |
| `~/.openclaw/goal-loop/goals.json`                | Goal Loop    | JSON     | Goal state persistence                                    |
| `~/.openclaw/goal-loop/{id}/iterations.jsonl`     | Goal Loop    | JSONL    | Per-goal iteration logs                                   |
| `~/.openclaw/goal-loop/{id}/evaluations.jsonl`    | Goal Loop    | JSONL    | Per-goal evaluation logs                                  |
| `~/.openclaw/planner/plans.json`                  | Planner      | JSON     | Plan state persistence                                    |
| `~/.openclaw/planner/{id}/tasks.jsonl`            | Planner      | JSONL    | Task state transitions                                    |
| `~/.openclaw/planner/{id}/worker-runs.jsonl`      | Planner      | JSONL    | Worker execution results                                  |
| `~/.openclaw/planner/{id}/evaluations.jsonl`      | Planner      | JSONL    | Planning/evaluation records                               |
| `~/.openclaw/researcher/researches.json`          | Researcher   | JSON     | Research state persistence                                |
| `~/.openclaw/researcher/{id}/rounds.jsonl`        | Researcher   | JSONL    | Research round logs                                       |
| `~/.openclaw/prds/*.md`                           | Researcher   | Markdown | Generated PRD documents                                   |
| `~/.openclaw/dashboard/trend-scout.json`          | Trend Scout  | JSON     | Scout configuration                                       |
| `~/.openclaw/dashboard/trend-digests/{date}.json` | Trend Scout  | JSON     | Daily trend digests                                       |
| `~/.openclaw/dashboard/tags.json`                 | Dashboard    | JSON     | Custom labels                                             |
| `~/.openclaw/dashboard/favorites.json`            | Dashboard    | JSON     | Starred items                                             |
| `~/.openclaw/dashboard/templates.json`            | Automation   | JSON     | Reusable templates                                        |
| `~/.openclaw/dashboard/webhooks.json`             | Automation   | JSON     | Webhook definitions                                       |
| `~/.openclaw/dashboard/chains.json`               | Automation   | JSON     | Chain definitions                                         |
| `~/.openclaw/cron/jobs.json`                      | Cron         | JSON     | Scheduled job definitions                                 |
| `~/.openclaw/agents/{id}/sessions/*.jsonl`        | Agent System | JSONL    | Per-agent session history                                 |
| `~/.openclaw/workspace-{id}/SOUL.md`              | Agent System | Markdown | Agent personality definition                              |
| `~/.openclaw/workspace-{id}/MEMORY.md`            | Agent System | Markdown | Agent persistent memory                                   |

## Appendix B: Complete CLI Reference

### Goal Loop CLI

```
openclaw goal <command>

Commands:
  start     Start a new goal loop
  stop      Stop a running goal
  status    Show goal status (single or all)
  list      List all goals (--active for running only)
  resume    Resume a stopped or budget-exceeded goal
  approve   Approve a quality gate for a paused goal
  reject    Reject a quality gate for a paused goal

Start Options:
  --goal <text>                  Goal description (required)
  --criteria <items...>          Acceptance criteria (space-separated)
  --agent-id <id>                Agent ID for iterations
  --budget-iterations <n>        Max iterations (default: 20)
  --budget-tokens <n>            Max tokens (default: 500000)
  --budget-time <duration>       Max time (e.g., 2h, 30m)
  --provider-usage-threshold <n> Provider usage % threshold (default: 80)
  --eval-every <n>               Evaluate every N iterations (default: 3)
  --eval-model <ref>             Model for evaluator
  --stall-threshold <n>          Flat evals before stall (default: 3)
  --quality-gate <iterations...> Pause at these iteration numbers
  --notify-channel <channel>     Notification channel
  --notify-to <recipient>        Notification recipient
  --notify-account-id <id>       Notification account ID

Resume Options:
  --add-iterations <n>           Add iterations to budget
  --add-tokens <n>               Add tokens to budget
  --add-time <duration>          Add time to budget
```

### Planner CLI

```
openclaw planner <command>

Commands:
  start     Start a new plan
  stop      Stop a running plan
  status    Show plan status (single or all)
  list      List all plans (--active for running only)
  tasks     Show task board (kanban view) for a plan
  resume    Resume a stopped or failed plan

Start Options:
  --goal <text>                  Goal description (required)
  --criteria <items...>          Acceptance criteria
  --from-prd <path>              Load goal/criteria from PRD file
  --max-turns <n>                Max agent turns (default: 50)
  --max-tokens <n>               Max tokens (default: 1000000)
  --max-time <duration>          Max time (e.g., 2h, 30m)
  --concurrency <n>              Max parallel workers (default: 3)
  --max-retries <n>              Per-task retry limit (default: 2)
  --replan-threshold <n>         Replan on batch failure rate % (default: 50)
  --notify-channel <channel>     Notification channel
  --notify-to <recipient>        Notification recipient
  --notify-account-id <id>       Notification account ID

Resume Options:
  --add-turns <n>                Add agent turns to budget
  --add-tokens <n>               Add tokens to budget
  --add-time <duration>          Add time to budget
```

### Researcher CLI

```
openclaw researcher <command>

Commands:
  start     Start a new research session
  stop      Stop a running research
  status    Show research status (single or all)
  list      List all researches (--active for active only)
  view      Show generated PRD content

Start Options:
  --goal <text>                  Goal description (required)
  --max-rounds <n>               Max interview rounds (default: 3)
  --max-turns <n>                Agent turn budget (default: 20)
  --max-tokens <n>               Token budget (default: 200000)
  --max-time <duration>          Wall clock limit (default: 30m)
  --notify-channel <channel>     Notification channel
  --notify-to <recipient>        Notification recipient
  --notify-account-id <id>       Notification account ID
```

### Gateway CLI

```
openclaw gateway run                 # Start the gateway process
  --bind loopback                    # Binding (loopback, all)
  --port 18789                       # Port number
  --force                            # Force start even if port in use

openclaw service install             # Install systemd service
openclaw service uninstall           # Remove systemd service

openclaw channels status             # Show channel status
  --probe                            # Probe connections

openclaw config set <key> <value>    # Set config value
openclaw config get <key>            # Get config value

openclaw doctor                      # Diagnose configuration issues
```

## Appendix C: Scout-Spec-Ship Playbook Summary

OpenClawd includes a built-in system improvement methodology called Scout-Spec-Ship (SSS). This is a 6-phase process for discovering, validating, building, and shipping system improvements:

| Phase      | Time Budget | Goal                             | Output                                        |
| ---------- | ----------- | -------------------------------- | --------------------------------------------- |
| **SCOUT**  | 5-10 min    | Identify improvement opportunity | 2-3 sentence Scout Note                       |
| **ASSESS** | 15-30 min   | Validate feasibility             | GO / NO-GO verdict                            |
| **SPEC**   | 10-20 min   | Write concrete plan              | Spec document with files, test plan, rollback |
| **BUILD**  | up to 2h    | Implement incrementally          | Working code with tests                       |
| **VERIFY** | 30 min      | E2E testing                      | All tests pass                                |
| **SHIP**   | 15 min      | Deploy and document              | Deployed, documented, knowledge saved         |

Key principle: **Brainstorming is cheap, building is expensive.** SSS front-loads validation so you never build something that doesn't work or isn't needed.

SSS runs as two automated cron jobs:

1. **Nightly Scout** (daily 02:00 UTC): Scans system for problems, writes proposals
2. **Vision Scout** (weekly Sundays 03:00 UTC): Looks forward at capability gaps
3. **Daily Self-Improvement** (daily 19:00 local): Executes one approved proposal

Proposals are stored at `~/.openclaw/workspace/memory/scout-proposals/` and reviewed via Discord or the dashboard.

## Appendix D: Docker Deployment

OpenClawd includes Docker support for containerized deployment:

```bash
# Build the image
docker compose -f deploy/docker-compose.gateway.yml build

# Run
docker compose -f deploy/docker-compose.gateway.yml up -d

# Image size: ~3.85 GB
# Config: deploy/.env (create from .env.example)
```

Docker mounts `~/.openclaw` at the same path for config compatibility. The container runs the gateway process with all extensions.

**Build Tips:**

- Normal rebuild (code changes): ~1-2 minutes with layer caching
- Full rebuild (`--no-cache`): ~13 minutes -- only use for Dockerfile or base image changes
- Config changes don't require rebuild -- just restart the container

---

_Last updated: 2026-02-05. Document covers all 6 extensions, 24 agents, and the complete OpenClawd system architecture._
